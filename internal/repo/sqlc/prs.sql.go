// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: prs.sql

package sqlc

import (
	"context"
)

const candidateForReassign = `-- name: CandidateForReassign :one
SELECT u.user_id
FROM users u
JOIN users oldr ON oldr.user_id = $1
JOIN pull_requests pr ON pr.pr_id = $2
WHERE u.team_name = oldr.team_name
  AND u.is_active = TRUE
  AND u.user_id <> pr.author_id
  AND u.user_id NOT IN (SELECT r.user_id FROM pr_reviewers r WHERE r.pr_id = pr.pr_id)
ORDER BY random()
LIMIT 1
`

type CandidateForReassignParams struct {
	OldUserID string `db:"old_user_id" json:"old_user_id"`
	PrID      string `db:"pr_id" json:"pr_id"`
}

func (q *Queries) CandidateForReassign(ctx context.Context, arg CandidateForReassignParams) (string, error) {
	row := q.db.QueryRow(ctx, candidateForReassign, arg.OldUserID, arg.PrID)
	var user_id string
	err := row.Scan(&user_id)
	return user_id, err
}

const candidatesForCreate = `-- name: CandidatesForCreate :many
SELECT u.user_id
FROM users u
JOIN users a ON a.user_id = $1
WHERE u.team_name = a.team_name
  AND u.is_active = TRUE
  AND u.user_id <> a.user_id
ORDER BY random()
LIMIT $2::int
`

type CandidatesForCreateParams struct {
	AuthorID   string `db:"author_id" json:"author_id"`
	LimitCount int32  `db:"limit_count" json:"limit_count"`
}

func (q *Queries) CandidatesForCreate(ctx context.Context, arg CandidatesForCreateParams) ([]string, error) {
	rows, err := q.db.Query(ctx, candidatesForCreate, arg.AuthorID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createPR = `-- name: CreatePR :one
INSERT INTO pull_requests (pr_id, name, author_id)
VALUES ($1, $2, $3)
RETURNING pr_id, name, author_id, status, created_at, merged_at
`

type CreatePRParams struct {
	PrID     string `db:"pr_id" json:"pr_id"`
	Name     string `db:"name" json:"name"`
	AuthorID string `db:"author_id" json:"author_id"`
}

func (q *Queries) CreatePR(ctx context.Context, arg CreatePRParams) (PullRequest, error) {
	row := q.db.QueryRow(ctx, createPR, arg.PrID, arg.Name, arg.AuthorID)
	var i PullRequest
	err := row.Scan(
		&i.PrID,
		&i.Name,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const deletePRReviewer = `-- name: DeletePRReviewer :exec
DELETE FROM pr_reviewers WHERE pr_id = $1 AND user_id = $2
`

type DeletePRReviewerParams struct {
	PrID   string `db:"pr_id" json:"pr_id"`
	UserID string `db:"user_id" json:"user_id"`
}

func (q *Queries) DeletePRReviewer(ctx context.Context, arg DeletePRReviewerParams) error {
	_, err := q.db.Exec(ctx, deletePRReviewer, arg.PrID, arg.UserID)
	return err
}

const getPR = `-- name: GetPR :one
SELECT pr_id, name, author_id, status, created_at, merged_at
FROM pull_requests
WHERE pr_id = $1
`

func (q *Queries) GetPR(ctx context.Context, prID string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, getPR, prID)
	var i PullRequest
	err := row.Scan(
		&i.PrID,
		&i.Name,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const getPRReviewers = `-- name: GetPRReviewers :many
SELECT user_id
FROM pr_reviewers
WHERE pr_id = $1
ORDER BY user_id
`

func (q *Queries) GetPRReviewers(ctx context.Context, prID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getPRReviewers, prID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPRsForReviewer = `-- name: GetPRsForReviewer :many
SELECT pr_id, name, author_id, status, created_at, merged_at
FROM pull_requests
WHERE pr_id IN (
  SELECT pr_id FROM pr_reviewers WHERE user_id = $1
)
ORDER BY created_at DESC
`

func (q *Queries) GetPRsForReviewer(ctx context.Context, userID string) ([]PullRequest, error) {
	rows, err := q.db.Query(ctx, getPRsForReviewer, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PullRequest{}
	for rows.Next() {
		var i PullRequest
		if err := rows.Scan(
			&i.PrID,
			&i.Name,
			&i.AuthorID,
			&i.Status,
			&i.CreatedAt,
			&i.MergedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPRReviewer = `-- name: InsertPRReviewer :exec
INSERT INTO pr_reviewers (pr_id, user_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type InsertPRReviewerParams struct {
	PrID   string `db:"pr_id" json:"pr_id"`
	UserID string `db:"user_id" json:"user_id"`
}

func (q *Queries) InsertPRReviewer(ctx context.Context, arg InsertPRReviewerParams) error {
	_, err := q.db.Exec(ctx, insertPRReviewer, arg.PrID, arg.UserID)
	return err
}

const updatePRStatusIfOpen = `-- name: UpdatePRStatusIfOpen :one
UPDATE pull_requests
SET status = 'MERGED',
    merged_at = COALESCE(merged_at, now())
WHERE pr_id = $1 AND status = 'OPEN'
RETURNING pr_id, name, author_id, status, created_at, merged_at
`

func (q *Queries) UpdatePRStatusIfOpen(ctx context.Context, prID string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, updatePRStatusIfOpen, prID)
	var i PullRequest
	err := row.Scan(
		&i.PrID,
		&i.Name,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}
