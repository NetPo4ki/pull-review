// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: teams.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTeam = `-- name: CreateTeam :exec
INSERT INTO teams (team_name)
VALUES ($1)
`

func (q *Queries) CreateTeam(ctx context.Context, teamName string) error {
	_, err := q.db.Exec(ctx, createTeam, teamName)
	return err
}

const getTeamWithMembers = `-- name: GetTeamWithMembers :many
SELECT
  t.team_name,
  u.user_id,
  u.username,
  u.is_active
FROM teams t
LEFT JOIN users u ON u.team_name = t.team_name
WHERE t.team_name = $1
ORDER BY u.user_id
`

type GetTeamWithMembersRow struct {
	TeamName string      `db:"team_name" json:"team_name"`
	UserID   pgtype.Text `db:"user_id" json:"user_id"`
	Username pgtype.Text `db:"username" json:"username"`
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
}

func (q *Queries) GetTeamWithMembers(ctx context.Context, teamName string) ([]GetTeamWithMembersRow, error) {
	rows, err := q.db.Query(ctx, getTeamWithMembers, teamName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeamWithMembersRow{}
	for rows.Next() {
		var i GetTeamWithMembersRow
		if err := rows.Scan(
			&i.TeamName,
			&i.UserID,
			&i.Username,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
